from __future__ import print_functionfrom discord.ext import commandsimport discordclass RankSelfAssignment(commands.Cog):    def __init__(self, client) -> None:        self.client = client        super().__init__()                # Rank: [Max Promotion Rank, Demotion Permissions]        self.rank_permissions = {            "Scout Commander":            ["Sergeant Major",      True],            "Colonel":              ["Sergeant Major",      True],            "Lieutenant Colonel":   ["Sergeant Major",      True],            "Major":                ["Sergeant Major",      True],            "Captain":              ["Sergeant Major",      True],            "1st Lieutenant":       ["Sergeant Major",      True],            "2nd Lieutenant":       ["Master Sergeant",     True],            "Sergeant Major":       ["Corporal",            False],            "Master Sergeant":      ["Corporal",            False],            "Sergeant First Class": ["Lance Corporal",      False],            "Staff Sergeant":       ["Private First Class", False]        }        # Rank: ["Associated Role 1", "Associated Role 2", ...]        self.rank_dictionary = {            'Scout Commander':            [], # Rank Self Assignment does not cover            'Colonel':              [],            'Lieutenant Colonel':   [],            'Major':                [],            'Captain':              [],            '1st Lieutenant':       [],            '2nd Lieutenant':       [],            'Sergeant Major':       ["Scout Enlisted", "Trooper", "Scout Sergeant",  "Sergeant Major"],            'Master Sergeant':      ["Scout Enlisted", "Trooper", "Scout Sergeant",  "Master Sergeant"],            'Sergeant First Class': ["Scout Enlisted", "Trooper", "Scout Sergeant",  "Sergeant First Class"],            'Staff Sergeant':       ["Scout Enlisted", "Trooper", "Scout Sergeant",  "Staff Sergeant"],            'Sergeant':             ["Scout Enlisted", "Trooper", "Scout Sergeant",  "Sergeant"],            'Corporal':             ["Scout Enlisted", "Trooper", "Corporal"],            'Lance Corporal':       ["Scout Enlisted", "Trooper", "Lance Corporal"],            'Private First Class':  ["Scout Enlisted", "Trooper", "Private First Class"],            'Private':              ["Scout Enlisted", "Trooper", "Private"],            'Scout Enlisted':               []        }    @commands.hybrid_command(name="rsa")    async def rankselfassignment(self, ctx: commands.Context, rank: str, promoter: discord.Member):        # If channel is not rank-self-assignment        if ctx.channel.name != "rank-self-assignment":            await ctx.send("Use the correct channel", ephemeral = True)            return        promoter_roles = [x.name for x in promoter.roles]        author_roles = [x.name for x in ctx.author.roles]                # If Promoter can not promote        if not any(x in promoter_roles for x in list(self.rank_permissions)):            await ctx.send(f"{promoter.mention} cannot promote!")            return        ranks = list(self.rank_dictionary)        promoter_rank = [x for x in promoter_roles if x in ranks][-1]        author_rank = [x for x in author_roles if x in ranks][-1]                # If Promoter can not promote up to Rank        if not ranks.index(self.rank_permissions[promoter_rank][0]) <= ranks.index(rank):            await ctx.send(f"{promoter.mention} can only promote up to {self.rank_permissions[promoter_rank][0]}")            return                # Check if the new Rank is a demotion from Current Rank        if ranks.index(rank) > ranks.index(author_rank):            # Check if the Promoter has demotion permissions and Promoter can demote Author's Rank            if self.rank_permissions[promoter_rank][1] and ranks.index(self.rank_permissions[promoter_rank][0]) <= ranks.index(author_rank):                # Send message                await ctx.send(f"{ctx.author.mention} was demoted by {promoter.mention} to {rank}")                # Calculate roles to add and roles to remove                roles_to_remove = self.rank_dictionary[author_rank]                roles_to_add = self.rank_dictionary[rank]                roles_to_remove = [discord.utils.get(ctx.guild.roles, name = x) for x in roles_to_remove if x not in roles_to_add]                roles_to_add = [discord.utils.get(ctx.guild.roles, name = x) for x in roles_to_add]                # Add and remove roles                await ctx.author.remove_roles(*roles_to_remove)                await ctx.author.add_roles(*roles_to_add)            else:                await ctx.send(f"{promoter.mention} cannot demote troopers!")        # If Rank is the same as author's rank        elif rank == author_rank:            await ctx.send(f'{ctx.author.mention} is already a {rank}!')        # Check if author has the correct roles for promotion        elif ranks[ranks.index(rank)+1] in author_roles:            # Send message            await ctx.send(f"{ctx.author.mention} was promoted by {promoter.mention} to {rank}")            # Calculate roles to add            roles_to_add = self.rank_dictionary[rank]            roles_to_add = [discord.utils.get(ctx.guild.roles, name = x) for x in roles_to_add]            # Add and Remove roles            await ctx.author.remove_roles(discord.utils.get(ctx.guild.roles, name=ranks[ranks.index(rank)+1]))            await ctx.author.add_roles(*roles_to_add)        else:            await ctx.send(f'This trooper must be a {ranks[ranks.index(rank)+1]} to be promoted to {rank}!')# Setup Function          async def setup(client: commands.Bot) -> None:    await client.add_cog(RankSelfAssignment(client))